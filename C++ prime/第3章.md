## using声明

- 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应该包含`using`声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。

## string

- 标准库类型`string`表示可变长的字符序列。
- `#include <string>`，然后 `using std::string;`
- **string对象**：注意，不同于字符串字面值。

### 定义和初始化string对象

初始化`string`对象的方式：

| 方式                  | 解释                                                    |
| --------------------- | ------------------------------------------------------- |
| `string s1`           | 默认初始化，`s1`是个空字符串                            |
| `string s2(s1)`       | `s2`是`s1`的副本                                        |
| `string s2 = s1`      | 等价于`s2(s1)`，`s2`是`s1`的副本                        |
| `string s3("value")`  | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本          |
| `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                |

- ==拷贝初始化==（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- ==直接初始化==（direct initialization）：通过括号给对象赋值。

### string对象上的操作

`string`的操作：

| 操作                 | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `os << s`            | 将`s`写到输出流`os`当中，返回`os`                            |
| `is >> s`            | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is`        |
| `getline(is, s)`     | 从`is`中读取一行赋给`s`，返回`is`                            |
| `s.empty()`          | `s`为空返回`true`，否则返回`false`                           |
| `s.size()`           | 返回`s`中字符的个数                                          |
| `s[n]`               | 返回`s`中第`n`个字符的引用，位置`n`从0计起                   |
| `s1+s2`              | 返回`s1`和`s2`连接后的结果                                   |
| `s1=s2`              | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1==s2`             | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2`             | 同上                                                         |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |

- string io：
  - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。
  - `getline`：读取一整行，**包括空白符**。
- ==`s.size()`返回的时`string::size_type`类型==，记住是一个**无符号**类型的值，不要和`int`混用
- `s1+s2`使用时，保证至少一侧是string类型。`string s1 = "hello" + "world" // 错误，两侧均为字符串字面值`
- **字符串字面值和string是不同的类型。**

### 处理string对象中的字符 `cctype`头文件

- ctype.h vs. cctype

  ：C++修改了c的标准库，名称为去掉

  ```
  .h
  ```

  ，前面加

  ```
  c
  ```

  。

  > 如c++版本为`cctype`，c版本为`ctype.h`

  - **尽量使用c++版本的头文件**，即`cctype`

`cctype`头文件中定义了一组标准函数：

| 函数          | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| `isalnum(c)`  | 当`c`是字母或数字时为真                                      |
| `isalpha(c)`  | 当`c`是字母时为真                                            |
| `iscntrl(c)`  | 当`c`是控制字符时为真                                        |
| `isdigit(c)`  | 当`c`是数字时为真                                            |
| `isgraph(c)`  | 当`c`不是空格但可以打印时为真                                |
| `islower(c)`  | 当`c`是小写字母时为真                                        |
| `isprint(c)`  | 当`c`是可打印字符时为真                                      |
| `ispunct(c)`  | 当`c`是标点符号时为真                                        |
| `isspace(c)`  | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)`  | 当`c`是大写字母时为真                                        |
| `isxdigit(c)` | 当`c`是十六进制数字时为真                                    |
| `tolower(c)`  | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c`         |
| `toupper(c)`  | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c`         |

### ==范围for（range for）==

- 遍历字符串：使用**范围for**（range for）语句： `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符。 （C++11）
  - ==**若要在使用范围for的循环体中改变字符串中的字符，必须要使用引用**==

## 练习3.9

下面的程序有何作用？它合法吗？如果不合法？为什么？

```
string s;
cout << s[0] << endl;
```

解：

不合法。使用下标访问空字符串是非法的行为。

## 练习3.11

下面的范围for语句合法吗？如果合法，c的类型是什么？

```
const string s = "Keep out!";
for(auto &c : s){ /* ... */ }
```

解：

要根据for循环中的代码来看是否合法，c是string 对象中字符的引用，s是常量。因此如果for循环中的代码重新给c赋值就会非法，如果不改变c的值，那么合法。



## vector

- vector是一个**容器**，也是一个类模板；
- vector表示一个对象的集合，集合中每个对象都有一个与之对应的索引
- `#include <vector>` 然后 `using std::vector;`
- 容器：“容纳”其他对象。
- 类模板：本身不是类或函数，但可以根据模板**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型。
- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。
- vector能容纳绝大多数类型的的对象作为其元素，但是因为引用不是对象，so不存在包含引用的vector

### 定义和初始化vector对象

初始化`vector`对象的方法

| 方法                        | 解释                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `vector<T> v1`              | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                               |
| `vector<T> v2 = v1`         | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本                 |
| `vector<T> v3(n, val)`      | `v3`包含了n个重复的元素，每个元素的值都是`val`               |
| `vector<T> v4(n)`           | `v4`包含了n个重复地执行了值初始化的对象                      |
| `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}`                                       |

- 列表初始化： `vector<string> v{"a", "an", "the"};` （C++11）

### 直接、拷贝、列表初始化vector==注意==

- 创建指定数量的元素

  `vector<int> ivec(10, -1)` 

  `vector<int> ivec(10)` //10个元素，初始化为0（内置类型未赋初值自动设为0） 

- ==初始化的真实含义依赖于传递初始值时使用的是`()`还是`{}`==

  - `vector<int> ivec(10)` //直接初始化 10个元素

  - `vector<int> ivec{10}` //列表初始化，1个元素，值=10

  - 如果使用花括号但是提供的值又不能使用列表初始化，就会考虑其他的初始化方式

    `vector<string> ivec{10}` //10个默认初始化的元素，因为不能用int类型初始化string类型
    `vector<string> ivec{10, "hi"}` //10个值为“hi“的元素



- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

tip：`buffer overflow`缓冲区溢出 就是指	通过下标访问不存在的元素这类错误。**确保下标合法，可以通过尽量使用范围for语句**

### `vector`支持的操作：

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `v.emtpy()`        | 如果`v`不含有任何元素，返回真；否则返回假                    |
| `v.size()`         | 返回`v`中元素的个数                                          |
| `v.push_back(t)`   | 向`v`的尾端添加一个值为`t`的元素                             |
| `v[n]`             | 返回`v`中第`n`个位置上元素的**引用**                         |
| `v1 = v2`          | 用`v2`中的元素拷贝替换`v1`中的元素                           |
| `v1 = {a,b,c...}`  | 用列表中元素的拷贝替换`v1`中的元素                           |
| `v1 == v2`         | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2`         | 同上                                                         |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较                                           |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的**下标运算符**，只能对确知已存在的元素执行下标操作，不能用于添加元素。

## 迭代器iterator

- 所有标准库容器都可以使用迭代器。但并不是所有的容器都可以使用下标运算符
- 类似于指针类型，迭代器也提供了对对象的间接访问。

### 使用迭代器与==迭代器失效==

- `vector<int>::iterator iter`。
- `auto b = v.begin();`返回指向第一个元素的迭代器。
- `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。
- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器。
- 使用解引用符`*`访问迭代器指向的元素。
- 养成使用迭代器和`!=`的习惯（泛型编程）。
- **容器**：可以包含其他对象；但所有的对象必须类型相同。
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。
- **`const_iterator`**：只能读取容器内元素不能改变。
  - begin和end 返回的类型由其对象决定，常量返回--`const_iterator`，变量--iterator
  - 如果使用`cbegin`和`cend`固定返回 `const_iterator`

- **箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`
- **==谨记==**：
  1. 但凡是使用了**迭代器**的循环体，都**不要**向迭代器所属的容器**添加元素**。
  2. 范围for的循环体中不能向vector对象添加元素
  3. 任何改变vector对象容量的操作，如`push_back`，都会使该vector对象的迭代器失效

标准容器迭代器的运算符:

| 运算符           |                             解释                             |
| ---------------- | :----------------------------------------------------------: |
| `*iter`          |            返回迭代器`iter`所指向的**元素的引用**            |
| `iter->mem`      |                     等价于`(*iter).mem`                      |
| `++iter`         |                令`iter`指示容器中的下一个元素                |
| `--iter`         |                令`iter`指示容器中的上一个元素                |
| `iter1 == iter2` | 判断两个迭代器是否相等,如果两个迭迭代器指示的是同一个元素，或者是同一个容器的尾后迭代器 |

### 迭代器运算

**`vector`和`string`迭代器支持的运算：**

| 运算符               | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `iter + n`           | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n`           | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1`      |
| `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1`      |
| `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。==两迭代器之间没有+运算符== |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器                             |

- **difference_type**：保证足够大以存储任何两个迭代器对象间的距离，可正可负。

  两迭代器相减， 迭代器得是同一个vector对象的

### 练习3.26

在100页的二分搜索程序中，为什么用的是 `mid = beg + (end - beg) / 2`, 而非 `mid = (beg + end) / 2 ;` ?

解：

因为两个迭代器相互之间支持的运算只有 `-` ，而没有 `+` 。 但是迭代器和迭代器差值（整数值）之间支持 `+`。

First, there is no operator `+` for two iterators. Second, for arithmetic types, using `mid = (beg + end) / 2` may lead to **overflow**.

2个原因啊

## 数组

- 相当于vector的低级版，**长度固定**。

### 定义和初始化内置数组

- 初始化：`char input_buffer[buffer_size];`，长度必须是`constexpr`常量表达式，或者不写，让编译器自己推断。
- **不允许使用auto来通过初始值列表推断数组类型**
- 类似vector，数组元素是对象，故没有存放引用的数组
- **数组不允许直接赋值给另一个数组，也不可使用vector初始化数组。**
  - 不允许拷贝和赋值

### 理解复杂的数组声明

- 指向数组的指针 `int (*a)[10]` a是一个指针，指向一个含有10个int的数组。  a没初始化，野指针
- 存放指针的数组 `int *a[10]`   a是一个数组， 存放10个int*
- 数组的引用  `int (&a)[10]` a引用一个含有10个int的数组

==从内往外，从右往左==

## 练习3.28

下列数组中元素的值是什么？

```
string sa[10];
int ia[10];
int main() {
	string sa2[10];
	int ia2[10];
}
```

解：

**数组的元素会被默认初始化。** `sa`的元素值全部为空字符串，`ia` 的元素值全部为0。 `sa2`的元素值全部为空字符串，`ia2`的元素值全部未定义。

## 练习3.29

相比于vector 来说，数组有哪些缺点，请例举一些。

解：

- 数组的大小是确定的。
- 不能随意增加元素。
- 不允许拷贝和赋值。

>- The size of the array is fixed and must be known when defined.
>- Character array needs to leave space for null character at the end.
>- Arrays can not be copied or assigned as a whole.
>- Array can not be constructed with the same values like the constructor of vector when defined.
>- The size of array must be calculated when using (sometimes cannot be calculated at all) instead of calling a `size()` method.

### 访问数组元素

范围for 、 下标，数组都支持

- 数组下标的类型：`size_t` 。
- 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
- 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。

## 练习3.33

对于104页的程序来说，如果不初始化scores将会发生什么？

解：If the `scores` array was defined inside a function, then the value of each element is undefined. If the `scores` array was defined outside any function, then the value of each element is 0.

函数内部定义，未初始化是 未定义的，   函数外部定义的话，未初始化，默认初始化为0

### 数组和指针

- 使用数组时，编译器一般会把它转换成指针。

- 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。

- **指针访问数组**：**一般情况下**，使用数组名时，名字会自动转换成指向数组的第一个元素的指针。如

  ```c
  int a[10];
  auto ia(a);  //ia是一个指针
  ```

  **但是**,当使用 `decltype`关键字时，不会发生上述转换。

  ```
  auto ia2(a) = {};   //ia2 的10个元素执行默认初始化。
  ```



### 指针也是迭代器  数组尾后元素

- 数组的指针支持 vector和string的迭代器的所有运算。

- ==数组也有尾后指针，类似于`迭代器.end()`。==尾后指针也不指向具体元素，故不能对尾后指针执行解引用/递增操作。

  ```
  int a[10];
  int *e = &a[10];
  ```

   ==由于使用尾后指针极易出错，故cpp 引入 `begin和end`函数，把数组作为参数==
  
  int *e = begin(arr);  



## C风格字符串

- 从C继承来的字符串。

- 用空字符结束（`\0`）。

- 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效。

- 允许使用字符数组来初始化string对象，or为其赋值。允许string的加法运算中有一个运算对象为字符数组。

- 上一条反过来不成立，**不可使用string对象来初始化or赋值string对象**

- 所以为获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 。

  `c_str（）  `返回一个c风格的字符串，

C标准库String函数，定义在`<cstring>` 中：

| 函数             | 介绍                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                               |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

**尽量使用vector和迭代器、string，少用数组和指针，c风格字符串**

### 使用数组初始化vector对象

不可使用数组为数组赋初值，也不能用vector初始化数组，但是可以

```c++
int arr[10] = {1,1,2,3,4};
vector<int> ivec(begin(arr), end(arr));
```

只需要指明需要拷贝区域的 首元素地址和尾后地址



### 使用范围for处理多维数组

除了最内层的循环可以不用引用，其他所有循环的控制变量都得是引用类型。

```c++
int ia[2][3];
for(auto &row : ia){
	for(auto &col : row){
		如果要改变元素的值，内层也要用引用
	}
}

```

**用引用的原因是，避免数组被编译器自动转换为指针。**

 **如果不使用auto来自动推断**

```
for(int (&row)[3] : ia){
	for(int &col : row)
}
```

==解析==：**第一层循环：遍历`ia`的元素，元素为大小为3的int类型数组**

## ==练习3.43 = 小结==

编写3个不同版本的程序，令其均能输出`ia`的元素。 版本1使用==范围`for`语句==管理迭代过程；版本2和版本3都使用普通`for`语句，其中版本2要求使用下标运算符，==版本3要求使用指针==。 此外，在所有3个版本的程序中都要直接写出数据类型，而不能使用类型别名、`auto`关键字和`decltype`关键字。

解：

```c++
#include <iostream>
using namespace std;

int main()
{
	int ia[2][3]= {1,2,3,4,5,6};
   for(int (&row)[3]  : ia){
   	for(int &col : row){
		cout << col;
	}
	   cout << endl;
   }
	
	for(size_t row = 0; row < 2; row++){
		for(size_t col = 0; col < 3; col++){
			cout << ia[row][col];
		}
		cout << endl;
	}
	
	//用指针 法一直接用指针
	for(int (*row)[3] = ia; row < ia+2; row++){
		for(int *col = *row; col < *row+3; col++){
			cout << *col;
		}
		cout << endl;
	}
	
	//用指针 法二用库函数 begin（） end（）
	for(auto row = begin(ia); row < end(ia); row++){
		for(auto col = begin(*row); col < end(*row); col++){
			cout << *col;
		}
		cout << endl;
	}
   return 0;
}
```

