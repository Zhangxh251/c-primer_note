# 第六章 函数

## 函数基础

- **函数定义**：包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体。
- **调用运算符**：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。
- 圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
- **形参和实参**：
  - 形参和实参的**个数**和**类型**必须匹配上。
  - 没有规定实参的求值顺序（顺序看编译器） 如`func(f1(), f2())`,如果 f1 和f2影响同一个对象，则可能引发错误（未定义的行为）
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。
- **名字**：名字的作用于是程序文本的一部分，名字在其中可见。 uiol。会改变。

### 局部对象

- **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。
- **局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，仅在函数内部可见， 且局部变量会颖仓在外层作用域单词同名的其他声明。
- **自动对象**：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。形参就是一种自动对象。
- **局部静态对象**： `static`类型的局部变量，生命周期贯穿函数调用前后。

## 练习6.6

说明形参、局部变量以及局部静态变量的区别。编写一个函数，同时达到这三种形式。

解：

形参定义在函数形参列表里面；局部变量定义在代码块里面； 局部静态变量在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止时才被销毁。

### 函数声明

- **函数声明**：

  - 函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。
  - 函数三要素（返回类型、函数名、形参类型）描述函数的接口，函数声明也称**函数原型**。

  - 声明的时候也可以省略形参的名字，写上更好理解

- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。

- **分离编译**： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。

## 参数传递

- 形参初始化的机理和变量初始化一样。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。 形参绑定到实参
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，**`C++`建议使用引用类型的形参代替指针。**

### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用形参可以用于**返回额外的信息**。
  - 如该情景：需要函数返回两个对象，此时可使用 一个额外的引用形参来隐式地返回该对象。
- 经常用引用形参来避免不必要的拷贝。
- 无需修改引用形参的值时，可以使用常量引用
- `void swap(int &v1, int &v2)`
- 如果无需改变引用形参的值，最好将其声明为常量引用。

## 练习6.14

举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。

解：

例如交换两个整数的函数，形参应该是引用

```
void swap(int& lhs, int& rhs)
{
	int temp = lhs;
	lhs = rhs;
	rhs = temp;
}
```

**当实参的值是==右值==时，形参不能为引用类型**

```
int add(int a, int b)
{
	return a + b;
}

int main()
{
	int i = add(1,2);
	return 0;
}
```

> lvalue
> 永久对象，可被取地址，可以出现在 operator= 左侧。
> 典型的 lvalue：有名称的变量、函数形参（栈中的对象）等。
>
> rvalue
> 临时对象（即将销毁），不可取地址，只能出现在 operator= 右侧（标准库中有例外，如string、complex 等）。
> 典型的 rvalue：字面常量（如1、2…等）、匿名对象（临时对象）以及函数的返回值等。另外，也可以通过 std::move 显式地将一个左值转换为右值。
> ————————————————
> 版权声明：本文为CSDN博主「peng1ei」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/pl20140910/article/details/82383143



### const形参和实参

- 用实参初始化形参时，形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
- 在函数中，不能改变实参的**局部副本**。
- **尽量使用常量引用。 因为非常量引用会限制函数所能接受的实参类型**
  - 不能把const对象、字面值、需要类型转换的对象传递给普通的引用形参



### 数组形参

- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
- 要注意数组的实际长度，不能越界。

#### 管理指针形参的3种技术（防止数组越界）

- 使用标记指定数组的长度

  如c风格的字符串，以 空字符来结尾

- 使用标准库规范

  形参传递 数组首元素和尾后元素的指针。 begin(arr) ， end(arr)
  
- 显示传递一个表示数组大小的形参。

