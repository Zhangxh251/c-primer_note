# 2.1.3字面值常量

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

## 转义序列

- 
- 泛化的转义序列：

其形式是\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。

## 列表初始化

要想定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点：

int units sold = 0；

int units sold ={0}； **列表初始化**

int units sold{0}；    **列表初始化**

int units sold（0）；

==注意==：当用于内置类型的变量时，这种初始化形式有一个重要特点：***如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：***

```c++
double b =1.1;
int a{b}，a = {b}; //报错
int a(b),c = b; //正确，转换执行且丢失部分值。
```



# 默认初始化

如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定**义于任何函数体之外的变量被初始化为0。**然而如6.1.1节（第185页）所示，一种例外情况是，**定义在函数体内部的内置类型变量将不被初始化（uninitialized）**。一个未被初始化的内置类型变量的值是未定义的（参见2.1.2节，第33页），如果试图拷贝或以其他形式访问此类值将引发错误。

# 2.2.2 变量声明和定义的关系

C++语言将声明和定义区分开来。

- 声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
- 而定义（definition）负责创建与名字关联的实体。（定义还申请存储空间，也可能会为变量赋一个初始值。）

​	如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：

extern int i；//声明i而非定义i

 int j；//声明并定义

extern double pi = 3.1416；//定义

由extern关键字标记的变量赋一个初始值，会抵消了 extern的作用。

==注意：==**在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。**

- 变量能且只能被定义一次，但是可以被多次声明。

如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

##练习2.5

小数默认 double 类型

##练习2.7

```
1024f
```
**无效**，因为后缀f只能用于浮点字面量，而1024是整型。



# 引用

此处指的是 “左值引用”

- **引用 = 对象的别名， 可以把引用  理解为  绑定**

- **定义**： 类型 &别名 = 对象   

  （**引用只能绑定在对象上**，不能于*字面量、表达式计算结果*绑定）

  例子： int a;    int &b  = a;

- **引用必须初始化。**  int  &a = b;//right       int &a; //false

- ==关于引用的引用==
不允许**直接**定义引用的引用的而只允许**间接**定义。

关于这部分内容的推荐：

《[c++ primer](https://www.zhihu.com/search?q=c%2B%2B+primer&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A101857476})》第五版（中文版）－－－P608至P612

>C++ 是否能够定义引用的引用？ - 二律背反的回答 - 知乎 https://www.zhihu.com/question/28023545/answer/101857476

- 除2种例外，**其他所有引用类型必须于之绑定的对象严格匹配。**

1. 55页

允许一个**常量引用**绑定非常量的对象、字面值、一般表达式，只要表达式的结果能转换成引用的类型

2. ==534页==

# 指针- ==534页内容待探索==

**除了2种例外**，**其他所有指针的类型必须和其所指向的对象==严格匹配==**

1. 常量指针可以指向非常量对象。（注意：`const int*`指向常量的指针仅要求不仅通过该常量指针修改其指向对象的值，但是该对象的值可由其他途径去改变）
2. 534页  暂时无法理解5

**因为**在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

个人见解：不同类型  有不同的空间长度，由此引发操作上的错误

## 空指针

- C++11 最好不要使用 `NULL` ,==使用`nullptr`==
- **把int 变量直接赋值给指针是错误的**。哪怕int变量 = 0 也不行。

​	int *p = 0;初始化为==字面量0==也是空指针

## void 指针

- void*是一种特殊的指针类型，可用于存放任意对象的地址。但，我们对该地址中到底是个什么类型的对象并不了解

​	概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。因为并不知道对象类型，也就无法确定能对这个对象能做那些操作

void能做的事情：

1. 拿它和别的指针比较
2. 作为函数的输入或输出，
3. 赋给另外一个void*指针，

## 练习2.19

说明指针和引用的主要区别

1. 指针是一个对象，而引用是一个对象的别名
2. 指针可以重新赋值以指向其他对象，而引用只能绑定一个变量之后不可更改。
3. 指针在定义时候可以不用初始化，而引用必须初始化。

可以int *a;   不允许 int &a;

## ==练习2.23==

给定指针 p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。

解：

在C++程序中，应该尽量初始化所有指针，并且尽可能等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它有没有指向一个具体的对象了。其中，nullptr是C++11新标准刚刚引入的一个特殊字面值，它可以转换成任意其他的指针类型。
在此前提下，判断p是否指向合法的对象，只需把p作为if语句的条件即可，如果
p的值是nullptr，则条件为假；反之，条件为真。
如果不注意初始化所有指针而贸然判断指针的值，则有可能引发不可预知的结果。<u>一种处理的办法是把if（p）置于try结构中，当程序块顺利执行时，表示p指向了合法的对象；当程序块出错跳转到catch语句时，表示p没有指向合法的对象。</u>

别人GitHub给出的

No, you can't. Because it would be expensive to maintain meta data about what constitutes a valid pointer and what doesn't, and in C++ you don't pay for what you don't want.

See answer [here](http://stackoverflow.com/a/17202622/5340808).

However, a *smart pointer* can be used to tell if it points to a valid object.

## 复合类型的声明

- 变量的定义包括  一种数据类型 和 一组声明符

```c
int i= 1024, *p=&i, &r = i;
```

- 我的编程习惯小问题：

正确风格：修饰符`*`紧跟变量

 `int   *p1, *p2, p`   p1和p2 是指针  p是变量

## 指向指针的引用

==引用不是一个对象，因此不能定义指向引用的指针。==

**但指针是对象，所以存在对指针的引用：**

```c
int*p；//p是一个int型指针
int *&r = p；//r是一个对指针p的引用

```

要理解r的类型到底是什么，最简单的办法是=**从右向左阅读r的定义**。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。

- 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。

# const

- onst对象**必须初始化**，且**不能被改变**。

- const变量默认不能被其他文件访问，且不同文件间的同名const变量视为不同的独立变量，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。

### ==对const的引用=“常量引用”==

- **reference to const**（对常量的引用）：const 类型名 &

常量引用只限定 引用的操作，如果引用的对象本身是非常量，则该量可通过其他途径改变其的值。

- 如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。

int &refva2 = ival; //错误！！试图让一个非常量引用指向一个常量对象

- ==允许一个**常量引用**绑定非常量的对象、字面值、一般表达式，==只要表达式的结果能转换成引用的类型

  (例外1，引用类型与绑定类型不匹配)

  double i = 10.1;
  const int &b = i;

  实际上 编译器执行

  const int temp = i； //由double类型生成一个临时的整型变量

  const int &b = temp;

  b绑定了一个**临时对象**/临时量

- 当b不是const修饰的常量时， 该操作非法。int &b = i;// illegal

也就是说 无法通过引用来修改const对象。

违反了**除2种例外， 引用类型必须与绑定类型严格匹配**。（上一个特性是==例外1==）

## 指针和const

### ==指向常量的指针pointer to const==

const int *p;

- 不能通过 **指向常量的指针** 改变其所指对象的值
- 只有**指向常量的指针**才能存放常量对象的地址 or 才能指向常量
- 与对const的引用的特性类似， 并不要求必须指向常量，只是不能通过它来改变对象的值。
- 并没有要求pointer to const 必须初始化 （不知道对不对）
- 其本身并不是常量，可以改变指向

### ==const pointer//常量指针==

int a = 0;

int *const p = &a；//p将一直指向a

- 常量指针必须初始化，且初始化完成后，其值就无法再改变。(存放在该指针中的地址)

**可以从右往左阅读。** 指针本身是一个常量。无法更改其指向的对象，但并未限制通过常量指针修改其指向对象的值。  （除非是指向常量的常量指针  const int *const p）

## 练习2.27

下面的哪些初始化是合法的？请说明原因。

解：

```
const int i = -1, &r = 0;   // 合法
const int *const p3 = &i2;  // 合法
const int *p1 = &i2;        // 合法
const int &const r2;        // 不合法, r2 是引用，引用没有顶层 const
const int i2 = i, &r = i;   // 合法
```

## 练习2.28

```
int i, *const cp;       // 不合法, const 指针必须初始化
int *p1, *const p2;     // 不合法, const 指针必须初始化
const int ic, &r = ic;  // 不合法, const int 必须初始化
const int *const p3;    // 不合法, const 指针必须初始化
const int *p;           // 合法. 一个指针，指向 const int
```

## 练习2.29

假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。

解：

```
i = ic;     // 合法, 常量赋值给普通变量
p1 = p3;    // 不合法, p3 是const指针不能赋值给普通指针   ！！！！
p1 = &ic;   // 不合法, 普通指针不能指向常量（我认为是对的
p3 = &ic;   // 合法, p3 是常量指针且指向常量
p2 = p1;    // 合法, 可以将普通指针赋值给常量指针
ic = *p3;   // 合法, 对 p3 取值后是一个 int 然后赋值给 ic
```



## 顶层const和底层const

- `顶层const`  top-level const：**指针本身是个常量。**
- `底层const`  low-level const：**指针指向的对象是个常量**。==执行拷贝时，拷入和拷出对象严格要求相同的底层const资格，==（或者拷出的数据类型 可以转换成拷入的数据类型，  右边转换成左边）**顶层const资格可以忽略**

一般而言：非常量可以转换成常量，反之8行。例如 常量只能被指向常量的指针所指，而指向常量的指针可以指向变量

- 也可以即是顶层const 也是底层const

这两个概念可以适合用于任何数据类型， const int a = 1；  //顶层const

![image-20220424234154881](%E7%AC%AC2%E7%AB%A0.assets/image-20220424234154881.png)

**常量引用是底层const**



# constexpr和常量表达式

- 常量表达式（const expression）：指值不会改变，且在编译过程中就能得到计算结果的表达式。
- 是不是常量表达式由它的数据类型和初始值共同决定

## constexpr变量

- `C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。声明为`constexpr`变量，它一定是一个常量，且必须使用常量表达式来初始化。
- tip： 如果认定一个变量时一个常量表达式，那就把它声明成 constexpr类型

## constexpr和指针

- **constexpr指针 的初始值必须是nullptr / 0 / 存储与某个固定地址中的对象**   也看看184，有比较多的限制
- **constexpr声明中如果定义了指针， constexpr限定符仅对指针本身有效，与指针所指向的对象无关**。==关键在于 constexpr把他所定义的对象置为顶层const==

```
const int*p = nullptr；
//p是一个指向整型常量的指针
constexpr int*q= nullptr；//q是一个指向整数的常量指针
```



## constexpr函数 p214

## 练习2.32

下面的代码是否合法？如果非法，请设法将其修改正确。

```
int null = 0, *p = null;
```

非法

*p = 0；或者 *p = NULL



# 类型别名 typedef

typedef 类型名 类型别名

## 别名声明

`using SI = Sales_item;`（C++11）

关键字 using 作为别名声明的开始

##==别名指代复合类型==（难点）

对于**复合类型**（指针等）不能代回原式来进行理解。**不是对别名的简单替换**

最好从 修饰这一角度来理解

```c
// 对于复合类型（指针等）不能代回原式来进行理解
typedef char *pstring;  // pstring是char*的别名
const pstring cstr = 0; // 指向char的常量指针
// 如改写为const char *cstr = 0;不正确，为指向const char的指针

// 辅助理解（可代回后加括号）  不知道对不对，我不是这么理解的
// const pstring cstr = 0;代回后const (char *) cstr = 0;
// const char *cstr = 0;即为(const char *) cstr = 0;
```

# auto类型说明符

- **auto**类型说明符：让编译器**自动推断类型**。 （会用表达式的值初始化其定义的变量）
- 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&和*)。`auto sz = 0, pi =3.14//错误`
- 一般，**会忽略`顶层const`**，**保留底层const**
- 如果希望是顶层const需要自己加`const`。`const int ci = 1; const auto f = ci;`f是const int
- 设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留。

# decltype类型指示符

- 希望从表达式的类型推断出要定义的变量的类型，但不想用该表达式的值初始化变量（与auto对应）
- 自然编译器也不会去计算表达式的值
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- **不会忽略`顶层const`。**

## decltype使用的表达式是变量时

此时，decltype处理`顶层const`和引用的方式与 auto不同。

- 返回该变量的类型 （包括其顶层const 和引用）

```c

const int ci = 0，&cj = ci；

decltype（ci）x = 0；//x的类型是 

const int decltype（cj）y= x；//y的类型是const int&，y绑定到变量x 

decltype（cj）z；//错误：z是一个引用，必须初始化 ！！！！！！
```

- 需要指出的是，**引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。**

## decltype使用的表达式不是一个变量时

**如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。**如4.1.1节（第120页）将要介绍的，有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：

1. 如果r是一个引用，但我想得到r所指的类型，
  那就把r作为表达式的一部分，如r+0。

  ```c
  int i=0, &r = i, k;
  decltype(r) x = k;  //x是一个引用。
  decltype(r + 0) y;  //y是一个未被初始化的int变量 
  ```

2. **如果表达式的内容是解引用操作，则decltype得到引用类型。**
```c
int i=0, *p = &i;
decltype(*p) c = 0;  //c是int&（引用）
```
3. **切记：decltype（（variable））（注意是双层括号）的结果==永远==是引用**，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。


  decltype 和 auto的另一处重要区别是，decltype的结果类型与表达式形式密切。相关。有一种情况需要特别注意：**对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。**如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型：如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：

## 练习2.37

**赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。**根据这一特点，请指出下面的代码中每一个变量的类型和值。

```
int a = 3, b = 4;
decltype(a) c = a;
decltype(a = b) d = a;
```

## 练习2.38

说明由decltype 指定类型和由auto指定类型有何区别。请举一个例子，decltype指定的类型与auto指定的类型一样；再举一个例子，decltype指定的类型与auto指定的类型不一样。

解：

decltype 处理顶层const和引用的方式与 auto不同，decltype会将顶层const和引用保留起来。

```c
int i = 0, &r = i;
//相同
auto a = i;
decltype(i) b = i;

//不同 d 是一个 int&
auto c = r;  //intl
decltype(r) d = r;
```
