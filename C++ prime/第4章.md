# 第四章 表达式

## 表达式基础

- **运算对象转换**：小整数类型会被提升为较大的整数类型

- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。

- 左值和右值：
  - C中原意：左值**可以**在表达式左边，右值不能。
  - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
  - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。
  - 使用关键字`decltype`时左值和右值也有所不同**。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型**。举个例子，假定p的类型是int*，因为解引用运算符生成左值，所以decltype（*p）的结果是int&。另一方面，**因为取地址运算符生成右值，所以decltype（&p）的结果是`int**`，**也就是说，结果是一个指向整型指针的指针。
  
- 求值顺序：

  ```
  int i = f1() + f2()
  ```

  - 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**
  - <u>但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义</u>
  -  **函数调用的先后顺序是不确定的**

## 算术运算符

- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。

- bool类型不应该参与计算

  - bool在参与运算的时候被提升为整数值1，如下所示-b = -1 ， -1作为b2初始值，由于不等于0所以转换成bool类型后为1。故b2 为true

  ```
  bool b=true;
  b0ool b2=-b;   //仍然为true
  //b为true，提升为对应int=1，-b=-1
  //b2=-1≠0，所以b2仍未true
  ```

- 取余运算m%n，结果符号与m相同

## 练习4.6

写出一条表达式用于确定一个整数是奇数还是偶数。

解：

```
if (i % 2 == 0) /* ... */
```

或者

```
if (i & 0x1) /* ... */
```

## 逻辑运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。**先左再右**
- 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。

```
vector<string> text;
for(const auto &s: text){
  cout<<s;
}
```

## 练习4.10

为`while`循环写一个条件，使其从标准输入中读取整数，遇到`42`时停止。

解：

```
int i;
while(cin >> i && i != 42)
```

## 赋值运算符

- 赋值运算的**返回结果是它的左侧运算对象**，且是一个左值。类型也就是左侧对象的类型。

- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。

- 如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间。（第二章列表初始化部分内容）

  - ==注意==：当用于内置类型的变量时，这种初始化形式有一个重要特点：***如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：***

    ```c++
    double b =1.1;
    int a{b}，a = {b}; //报错
    int a(b),c = b; //正确，转换执行且丢失部分值。
    ```

    

- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`

- 赋值运算优先级比较低，使用其当条件时应该加括号。

- 复合赋值运算符，**复合运算符只求值一次**，普通运算符求值两次。（对性能有一点点点点影响） 任意复合运算符op等价于`a = a op b;`

  

## 递增递减运算符

- 前置版本`j = ++i`，先加一后赋值
- 后置版本`j = i++`，先赋值后加一

==**优先使用前置**版本，后置多一步储存原始值。==（除非需要变化前的值）影响性能



## ==运算对象可按任意顺序求值==

一般大多数运算符都没有规定运算对象的求值顺序，这在一般情况下不会有什么影响。**如果在一个表达式中，一个子表达式改变了某个运算对象的值，而另一个子表达式又要使用该值，此时求值顺序就非常关键。**因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。

该程序使用for循环将输入的第一个单词改成大写形式：

`for（auto it = s.begin（）；it！= s.end（）&&！isspace（*it）；++it）
*it = toupper（*it）；`//将当前字符改成大写形式，

在上述程序中，我们把解引用it和递增it两项任务分开来完成。如果用一个看似等价的while循环进行代替
//该循环的行为是未定义的！
`while（beg！= s.end（）&&！isspace（*beg））
*beg = toupper（*beg++）；`//错误：该赋值语句未定义.

将产生未定义的行为。问题在于：赋值运算符左右两端的运算对象都用到了beg，并且右侧的运算对象还改变了beg的值，所以该赋值语句是未定义的。编译器可能按照下面的任意一种思路处理该表达式：
`*beg = toupper（*beg）；//如果先求左侧的值
*（beg + 1）= toupper（*beg）；`//如果先求右侧的值 

也可能采取别的什么方式处理它。

## ==练习4.19==

假设`ptr`的类型是指向`int`的指针、`vec`的类型是`vector`、`ival`的类型是`int`，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？

```
(a) ptr != 0 && *ptr++  
(b) ival++ && ival
(c) vec[ival++] <= vec[ival] 
```

解：

- (a) 判断`ptr`不是一个空指针，并且`ptr`当前指向的元素的值也为真，然后将`ptr`指向下一个元素

- (b) 判断`ival`的值为真，并且`(ival + 1)`的值也为真

- (c) ==该表达式未定义==。C++并没有规定`<=`运算符两边的求值顺序，

  该表达式在左右两端都使用了`vec[ival]`, 左侧还修改了ival的值



## 成员访问运算符

```
ptr->mem`等价于`(*ptr).mem
```

**注意`.`运算符优先级大于`*`**，所以记得加括号

## 练习4.20

假设`iter`的类型是`vector::iterator`, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？

```
(a) *iter++;
(b) (*iter)++;
(c) *iter.empty();
(d) iter->empty();
(e) ++*iter;
(f) iter++->empty();
```

解：

- (a)合法。返回迭代器所指向的元素，然后迭代器递增。
- **(b)不合法。因为`vector`元素类型是`string`，没有`++`操作。**
- (c)不合法。这里应该加括号。
- (d)合法。判断迭代器当前的元素是否为空。
- **(e)不合法。`string`类型没有`++`操作。**
- (f)合法。判断迭代器当前元素是否为空，然后迭代器递增。

## 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

- 可以嵌套使用，**右结合律**，从右向左顺序组合

  - ```
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等价于
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    ```

- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。

## 练习4.23

因为运算符的优先级问题，下面这条表达式无法通过编译。根据4.12节中的表指出它的问题在哪里？应该如何修改？

```
string s = "word";
string pl = s + s[s.size() - 1] == 's' ? "" : "s" ;
```

解：

加法运算符的优先级高于条件运算符。因此要改为：

```
string pl = s + (s[s.size() - 1] == 's' ? "" : "s") ;
```



## 位运算符

用于检查和设置二进制位的功能。

- 位运算符是作用于**整数类型**的运算对象。

- **“小整型”会被自动==提升==为较大的整数类型**

- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。

  - 位移运算符右侧运算对象 必须为 正值，且值严格小于结果的位数

  - **把经过位移的左侧运算对象的==拷贝==作为运算结果**
  - ```c++
    	int i = 1;
    	
    	cout << (i << 1)<< endl;  //输出结果2
    	cout << i;				// i实际 = 1
    	
    ```

    

- 位取反（`~`）（逐位求反）、与（`&`）、或（`|`）、异或（`^`）

有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。

对于有符号数，左移可能导致符号位的值改变

- 移位运算符满足左结合律，优先级介于中间，优先级低于算数运算符，高于关系、赋值、条件运算符，使用时尽量加括号。

## 练习4.25

如果一台机器上`int`占32位、`char`占8位，用的是`Latin-1`字符集，其中字符`'q'` 的二进制形式是`01110001`，那么表达式`~'q' << 6`的值是什么？

解：

**首先将`char`类型==提升==为`int`类型**，即`00000000 00000000 00000000 01110001`，然后取反，再左移6位，结果是-7296。

## sizeof运算符

- 返回一条表达式或一个类型名字所占的**字节数**。

- 返回的类型是 `size_t`的常量表达式。

- `sizeof`并不实际计算其运算对象的值。

- 两种形式：

  1. `sizeof (type)`，给出类型名
  2. `sizeof expr`，给出表达式

- 允许使用作用域运算符获取类成员的大小，sizeof访问类成员不受权限限制。

  `sizeof Sales_data::revenue`获取Sales_data的revenue成员对应类型的大小。

- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，**指针不需有效。**因为不需要解引用指针就可以知道其所指对象的类型

- **对char或者类型为char的表达式执行sizeof运算，结果得1。**

- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。

- 对指针执行sizeof运算得到指针本身所占空间的大小。

- **对`string`和`vector`对象执行sizeof运算，不会计算对象中元素占用了多少空间，只会返回该类型固定部分的大小**。（这个STL实现的底层代码有关）

- sizeof不会把数组当作指针来处理。可以用来获取整个数组大小

## 逗号运算符

从左向右依次求值。

左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。

**逗号表达式的优先级是最低的**

## ==练习4.33==

根据4.12节中的表说明下面这条表达式的含义。

```
someValue ? ++x, ++y : --x, --y
```

解：

逗号表达式的优先级是最低的。因此这条表达式也等于：

```
(someValue ? ++x, ++y : --x), --y
```

如果`someValue`的值为真，`x` 和 `y` 的值都自增并返回 `y` 值，然后丢弃`y`值，`y`递减并返回`y`值。如果`someValue`的值为假，`x` 递减并返回`x` 值，然后丢弃`x`值，`y`递减并返回`y`值。



## 类型转换

### 隐式类型转换

> 设计为尽可能避免损失精度，即转换为更精细类型。

- 比 `int`类型小的整数值先提升为较大的整数类型。

- 条件中，非布尔转换成布尔。

- 初始化中，初始值转换成变量的类型。赋值语句中，右侧运算对象转换成左侧对象的类型

- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。

- 函数调用时也会有转换。

- 指针的转换：

  - 0 or nullpter 可以转换成任意类型的指针
  - 指向任意非常量的指针可以转换成 void*
  - 指向任意对象的指针可以-> const void*

- 类类型定义的转换：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行种类类型的转换。在7.5.4节（第263页）中我们将看到一个例子，如果同时提出多个转换请求，这些请求将被拒绝。

  前面使用过这转换的 代码

  ```
  string s，t="a value"；
  //字符串字面值转换成string类型
  while（cin >> s）
  //while的条件部分把cin转换成布尔值
  ```

  

#### 算术转换

运算符的对象转换为其中最宽的类型 如`int + long doubule`就把int-> long  double

##### 整型提升

- 常见的char、bool、short能存在int就会转换成int，否则提升为`unsigned int`
- `wchar_t,char16_t,char32_t`提升为整型中`int,long,long long ……`最小的，且能容纳原类型所有可能值的类型。

#### ==无符号类型的运算对象==

如果一个是无符号类型，另一个是带符号类型，

- 其中无符号类型宽度不小于带符号类型

  带符号类型对象转换为无符号类型，**（小心产生意想不到的结果）**

  ```c++
  	int i = -2;
  	unsigned int j = 1;
     cout << i+j <<endl;   //4294967295
  
  
  int i = -2;
  	unsigned char j = 1;
     cout << i+j <<endl;   //-1
  ```

- 带符号类型宽度大于无符号类型

  此时转换的结果依赖于机器。如果无符号类型的<u>所有值</u>都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是1ong和unsigned int，并且int和long的大小相同，则1ong类型的运算对象转换成unsigned int类型；如果1ong类型占用的空间比int更多，则unsigned int类型的运算对象转换成 1ong类型。

#### 其他转换

> p143



## 练习4.35

假设有如下的定义：

```
char cval;
int ival;
unsigned int ui;
float fval;
double dval;
```

请回答在下面的表达式中发生了隐式类型转换吗？如果有，指出来。

```
(a) cval = 'a' + 3;
(b) fval = ui - ival * 1.0;
(c) dval = ui * fval;
(d) cval = ival + fval + dval;
```

解：

- (a) `'a'` 转换为 `int` ，然后与 `3` 相加的结果转换为 `char`
- (b) `ival` 转换为 `double`，`ui` 转换为 `double`，结果转换为 `float`
- (c) `ui` 转换为 `float`，结果转换为 `double`
- (d) `ival` 转换为 `float`，与`fval`相加后的结果转换为 `double`，最后的结果转换为`char`



### 显式类型转换（尽量避免）

形式：`cast-name<type>(expression)`

cast-name:

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`

  - 可以使用static_cast找回存在于void*中的指针。（应该确保指针的指保持不变，即强制转换的结果与原始的地址值相等，因此必须确保转换后得到了类型就是指针所指的类型。 否则，类型不符合，会产生未定义的后果）

- **dynamic_cast**：支持运行时类型识别。19.2节

- **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`

  > 只有其可以改变常量属性

- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。

  ==非常危险==，很容易出bug

#### 旧式强制类型转换

```
type expr
```

## 练习4.37

练习4.37 用命名的强制类型转换改写下列旧式的转换语句。

```
int i; double d; const string *ps; char *pc; void *pv;
(a) pv = (void*)ps;
(b) i = int(*pc);
(c) pv = &d;
(d) pc = (char*)pv;
```

解：

```
(a) pv = static_cast<void*>(const_cast<string*>(ps));
(b) i = static_cast<int>(*pc);
(c) pv = static_cast<void*>(&d);
(d) pc = static_cast<char*>(pv);
```

对于（a），不先去掉const ,会变成 const void*？



## 练习4.38

说明下面这条表达式的含义。

```
double slope = static_cast<double>(j/i);
```

The expression first did integral division `j / i`, then converted the result to `double` and assigned it to `slope`. The result is the same as `double slope = j / i;`
